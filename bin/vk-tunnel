#!/usr/bin/env node

const packageJson = require('../package.json');
const WebSocketClient = require('websocket').client;
const WebSocket = require('ws');
const pino = require('pino');
const prompt = require('prompts');
const chalk = require('chalk');
const Configstore = require('configstore');
const vault = new Configstore(packageJson.name, {});
const httpParser = require('http-string-parser');
const fs = require('fs');
const querystring = require('querystring');
const request = require('./request');

const logger = pino({
  prettyPrint: { colorize: true },
  level: process.env.LOGLEVEL || 'info',
  base: {},
  timestamp: () => {
    const date = new Date();
    // Такой странный вариант возвращают все внутренние функции pino
    return `,"time":"${date.toLocaleDateString()} ${date.toLocaleTimeString()}"`;
  }
});

let configJSON = {};
if (fs.existsSync('./vk-tunnel-config.json')) {
  configJSON = require('require-module')('./vk-tunnel-config.json');
}
const cfg = configJSON || {};

const TUNNEL_APP_ID = 7357112;
const CLIENT_VERSION = 1;

const API_HOST = cfg.api_host || 'https://api.vk.com/method/';
const OAUTH_HOST = cfg.oauth_host || 'https://oauth.vk.com/';
const API_VERSION = cfg.api_version || '5.100';

const SEQ_BEGIN = 0;
const SEQ_END = 8;

const MSG_TYPE_BEGIN = 8;
const MSG_TYPE_END = 9;

const PAYLOAD_BEGIN = 9;

const ACCEPT_ENCODING = 'Accept-Encoding';
const DISABLE_COMPRESS = 'gzip;q=0,deflate;q=0';

const OAUTH_USER_REVOKE_TOKEN_ERROR = 5;

async function api(method, params) {
  params.v = API_VERSION;
  params.access_token = cfg.access_token;

  const { data } = await request(`${API_HOST}${method}?${querystring.stringify(params)}`, {
    validateStatus: (status) => status >= 200 && status < 500
  });

  if (data.error) {
    logger.error(chalk.red(`${data.error.error_code}: ${data.error.error_msg}`));

    if (data.error.error_code === OAUTH_USER_REVOKE_TOKEN_ERROR) {
      vault.delete('access_token');
      vault.delete('user_id');

      logger.warn(chalk.yellow('Previous settings has been removed'));
    }
  }

  return data.response;
}

async function oauth(name, params) {
  const { data } = await request(`${OAUTH_HOST}${name}?${querystring.stringify(params)}`, {
    validateStatus: (status) => status >= 200 && status < 500
  });

  return data;
}

async function auth() {
  const { error, auth_code, device_id } = await oauth('get_auth_code', {
    scope: 'offline',
    client_id: TUNNEL_APP_ID
  });

  if (error) {
    return Promise.reject('Failed auth code ' + JSON.stringify(error));
  }

  while (true) {
    const promptQuestion = await prompt({
      type: 'confirm',
      name: 'result',
      initial: true,
      message: chalk.yellow(
        'Please open and approve authentication ',
        `${OAUTH_HOST}code_auth?stage=check&code=${auth_code}`
      )
    });

    if (!promptQuestion.result) {
      process.exit(0);
    }

    const codeAuthTokenResult = await oauth('code_auth_token', {
      device_id,
      client_id: TUNNEL_APP_ID
    });

    if (codeAuthTokenResult.access_token) {
      return codeAuthTokenResult;
    }

    logger.info('Auth failed, retrying...');
  }
}

async function getTunnelToken() {
  if (!cfg.access_token && vault.get('access_token')) {
    cfg.access_token = vault.get('access_token');
    cfg.user_id = vault.get('user_id');
  }

  if (!cfg.access_token) {
    logger.info('Try to retrieve access token...');

    const { access_token, user_id } = await auth();

    cfg.access_token = access_token;
    cfg.user_id = user_id;

    vault.set('access_token', access_token);
    vault.set('user_id', user_id);
  }

  const data = await api('apps.getTunnelToken', {
    version: CLIENT_VERSION
  });

  if (data.token) {
    cfg.tunnelToken = data.token;
    cfg.hostSuffix = data.suffix;
    cfg.wsAddr = data.host;
    cfg.wsURL = data.url;

    logger.debug('tunnel token:', cfg.tunnelToken);

    return cfg.tunnelToken;
  }

  logger.error('Can\'t retrieve tunnel token');
  process.exit(1);
}

function filterHeaders(payload, proxyHost) {
  return payload
    .replace(/Accept-Encoding:.*/, ACCEPT_ENCODING + ': ' + DISABLE_COMPRESS)
    .replace(/Host: .*/, 'Host: ' + proxyHost);
}

function getHelpMessage() {
  return '\n' +
    'Example vk-tunnel --host=localhost --port=10888:\n\n' +
    'Environment variables and options:\n' +
    chalk.yellow(
      '--host (PROXY_HOST)\t\t- host of your application (for example: localhost)\n' +
      '--port (PROXY_POST)\t\t- port of your application (for example: 10888)\n' +
      '--http-protocol (PROXY_HTTP_PROTO)\t- http/https (by default: http)\n' +
      '--ws-protocol (PROXY_WS_PROTO)\t\t- ws/wss (by default: ws)\n'
    );
}

function parseOptions() {
  for (let i = 2; i < process.argv.length; i++) {
    const [option, value] = process.argv[i].split('=');

    if (option === '-h') {
      console.log(getHelpMessage());
      process.exit(0);
    }

    switch (option) {
      case '--port':
        process.env.PROXY_PORT = value;
        break;
      case '--host':
        process.env.PROXY_HOST = value;
        break;
      case '--ws-protocol':
        process.env.PROXY_WS_PROTO = value;
        break;
      case '--http-protocol':
        process.env.PROXY_HTTP_PROTO = value;
        break;
      case '--insecure':
        process.env.NODE_TLS_REJECT_UNAUTHORIZED = value === '1' ? '0' : '1';
        break;
      default:
        logger.info('Skip unknown option', option);
        break;
    }
  }
}

async function run() {
  parseOptions();

  const tunnelToken = await getTunnelToken();

  const PROXY_HOST = process.env.PROXY_HOST || 'localhost';
  const PROXY_HTTP_PROTO = process.env.PROXY_HTTP_PROTO || 'http';
  const PROXY_WS_PROTO = process.env.PROXY_WS_PROTO || 'ws';
  const PROXY_PORT = process.env.PROXY_PORT || '10888';

  const TYPE_HTTP = '\0';
  const TYPE_WEBSOCKET = '\1';
  const TYPE_CLOSE = '\b';

  const url = cfg.wsAddr + '/' + cfg.wsURL;
  const connections = {};

  logger.debug('initialize', url);

  const client = new WebSocketClient();

  client.connect(url, null, null, {
    UserID: cfg.user_id,
    Token: tunnelToken
  });

  client.on('connectFailed', (error) => {
    logger.error('Connect error:', error.toString());
  });

  client.on('connect', (connection) => {
    logger.debug('connected to', url);

    console.log('\n' +
      chalk.blue(
        ' _____ _____    _____ _____ _____ _____ _____ __    \n' +
        '|  |  |  |  |  |_   _|  |  |   | |   | |   __|  |   \n' +
        '|  |  |    -|    | | |  |  | | | | | | |   __|  |__ \n' +
        ' \\___/|__|__|    |_| |_____|_|___|_|___|_____|_____|\n' +
        '\n')
    );

    console.log(`open: https://user${cfg.user_id}-${cfg.hostSuffix}.wormhole.vk-apps.com/`);

    connection.on('close', (code) => {
      logger.info('Disconnected, code:', code);
    });

    connection.on('error', (error) => {
      logger.error('wsMain error', error);
    });

    connection.on('message', async (data) => {
      const rawWsRequest = data.binaryData.toString();
      const seq = rawWsRequest.slice(SEQ_BEGIN, SEQ_END);
      const msgType = rawWsRequest.slice(MSG_TYPE_BEGIN, MSG_TYPE_END);
      const payload = rawWsRequest.slice(PAYLOAD_BEGIN);
      const endpoint = payload.split(' ')[1];

      if (msgType !== TYPE_HTTP) {
        const filteredPayload = filterHeaders(payload, PROXY_HOST);

        if (msgType === TYPE_CLOSE) {
          logger.debug('ws close', seq);

          if (connections[seq]) {
            connections[seq].close();
          }

          return;
        }

        connections[seq].send(filteredPayload, {}, () => {
          logger.debug('ws request seq:', seq, msgType, endpoint, filteredPayload);
        });
      }

      if (typeof data !== 'object') {
        return connection.sendBytes('', () => {
          logger.debug('pong');
        });
      }

      if (msgType !== TYPE_HTTP) {
        return;
      }

      if (connections[seq]) {
        logger.info('connection already exists', seq);
      }

      const parsedRequest = httpParser.parseRequest(payload.toString());

      parsedRequest.headers.Host = PROXY_HOST;
      parsedRequest.headers[ACCEPT_ENCODING] = DISABLE_COMPRESS;

      const upgradeHeader = parsedRequest.headers.Upgrade || '';
      const isWebsocketUpgrade = upgradeHeader.toLowerCase() === 'websocket';

      if (isWebsocketUpgrade) {
        logger.debug('upgrade to websocket', endpoint);

        const tunnelUrl = `${PROXY_WS_PROTO}://${PROXY_HOST}:${PROXY_PORT}${endpoint}`;

        if (connections[seq]) {
          logger.debug('upgrade request', seq.toString(), msgType.charCodeAt(0), endpoint);
        }

        logger.debug('create connection', seq);

        connections[seq] = new WebSocket(tunnelUrl, [], {});

        connections[seq].on('error', (msg) => {
          logger.error('Connection error for', seq, msg);
        });

        connections[seq].on('upgrade', (msg) => {
          const response = ['HTTP/1.1 101 Switching Protocols'];

          for (const key in msg.headers) {
            response.push(`${key}: ${msg.headers[key]}`);
          }

          response.push('\n');

          connection.sendUTF(seq + TYPE_HTTP + response.join('\n'), () => {
            logger.debug('send reply upgrade', seq);
          });
        });

        logger.debug('ws connect', tunnelUrl);

        connections[seq].on('open', () => {
          connections[seq].on('message', (data) => {
            logger.debug('incoming ws message from service', seq);

            connection.sendUTF(seq + TYPE_WEBSOCKET + data, () => {
              logger.debug('send reply', seq);
            });
          });
        });

        return;
      }

      const response = await request({
        url: `${PROXY_HTTP_PROTO}://${PROXY_HOST}:${PROXY_PORT}${parsedRequest.uri}`,
        data: parsedRequest.body,
        headers: parsedRequest.headers,
        method: parsedRequest.method,
        responseType: 'arraybuffer',
        timeout: 5000,
        validateStatus: (status) => status >= 200 && status < 500
      }).catch((err) => {
        logger.error('502 Error:', err.message);

        // await Promise.reject().catch(() => 10) вернет 10
        return {
          status: 502,
          statusText: 'Bad gateway',
          headers: {
            'content-type': 'text/html'
          },
          data: Buffer.from('Bad gateway', 'utf8')
        };
      });

      let rawResponse = `HTTP/1.1 ${response.status}  ${response.statusText}\r\n`;

      for (const key in response.headers) {
        if (key === 'transfer-encoding') {
          continue;
        }

        if (key === 'content-length' && ('transfer-encoding' in response.headers)) {
          rawResponse += `content-length: ${response.data.length}\r\n`;
          continue;
        }

        rawResponse += `${key}: ${response.headers[key]}\r\n`;
      }

      rawResponse += '\r\n';

      const buffer = Buffer.concat([
        Buffer.from(seq, 'utf8'),
        Buffer.from(msgType, 'utf8'),
        Buffer.from(rawResponse),
        response.data
      ]);

      connection.sendBytes(buffer, () => {
        const normalMsgType = ({
          [TYPE_HTTP]: 'HTTP',
          [TYPE_WEBSOCKET]: 'WebSocket',
          [TYPE_CLOSE]: 'Close'
        })[msgType] || msgType;

        const realIp = parsedRequest.headers['X-Real-Ip'] || '-';
        const statusCode = response.status || '-';
        const host = parsedRequest.headers.Host || '-';
        const method = parsedRequest.method || '-';
        const uri = parsedRequest.uri || '-';
        const length = response.data.length;

        logger.debug(`seq: ${seq}, message type: ${normalMsgType}`);
        logger.info(`ip: ${realIp}, code: ${statusCode}, host: ${host}, method: ${method}, path: ${uri}, len: ${length}`);
      });
    });
  });
}

run().catch((err) => logger.error(err));
